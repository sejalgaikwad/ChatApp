"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getPackageData = exports.encodePackageName = undefined;

require("babel-polyfill");

var _requestPromiseNative = require("request-promise-native");

var _requestPromiseNative2 = _interopRequireDefault(_requestPromiseNative);

var _httpsProxyAgent = require("https-proxy-agent");

var _httpsProxyAgent2 = _interopRequireDefault(_httpsProxyAgent);

var _child_process = require("child_process");

var _semver = require("semver");

var _constants = require("./constants");

var C = _interopRequireWildcard(_constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Encodes the package name for use in a URL/HTTP request
 * @param {string} packageName - the name of the package to encode
 */
/* eslint-disable no-param-reassign, no-shadow, consistent-return */
function encodePackageName(packageName) {
  // Thanks https://github.com/unpkg/npm-http-server/blob/master/modules/RegistryUtils.js
  // for scoped modules help
  var encodedPackageName = void 0;
  if (packageName[0] === "@") {
    // For the registry URL, the @ doesn't get URL encoded for some reason
    encodedPackageName = "@" + encodeURIComponent(packageName.substring(1));
  } else {
    encodedPackageName = encodeURIComponent(packageName);
  }
  return encodedPackageName;
}

/**
 * Gets metadata about the package from the provided registry
 * @param {Object} requestInfo - information needed to make the request for the data
 * @param {string} requestInfo.encodedPackageName - the urlencoded name of the package
 * @param {string} requestInfo.registry - the URI of the registry on which the package is hosted
 * @returns {Promise<Object>} - a Promise which resolves to the JSON response from the registry
 */
function getPackageData(_ref) {
  var encodedPackageName = _ref.encodedPackageName,
      registry = _ref.registry,
      auth = _ref.auth,
      proxy = _ref.proxy;

  var requestHeaders = {};
  if (auth) {
    requestHeaders.Authorization = "Bearer " + auth;
  }

  var options = {
    uri: registry + "/" + encodedPackageName,
    resolveWithFullResponse: true,
    // When simple is true, all non-200 status codes throw an
    // error. However, we want to handle status code errors in
    // the .then(), so we make simple false.
    simple: false,
    headers: requestHeaders
  };

  // If any proxy setting were passed then include the http proxy agent.
  var requestProxy = process.env.HTTP_PROXY || process.env.http_proxy || "" + proxy;
  if (requestProxy !== "undefined") {
    options.agent = new _httpsProxyAgent2.default(requestProxy);
  }

  return (0, _requestPromiseNative2.default)(options).then(function (response) {
    var statusCode = response.statusCode;

    if (statusCode === 404) {
      throw new Error("That package doesn't exist. Did you mean to specify a custom registry?");
    }
    // If the statusCode not 200 or 404, assume that something must
    // have gone wrong with the connection
    if (statusCode !== 200) {
      throw new Error("There was a problem connecting to the registry.");
    }
    var body = response.body;

    var parsedData = JSON.parse(body);
    return parsedData;
  });
}

/**
 * Spawns the package manager
 * @param {string} command - the command to spawn
 * @returns {Promise} - a Promise which resolves when the install process is finished
 */
function spawnInstall(command, args) {
  return new Promise(function (resolve, reject) {
    // Spawn install process
    var installProcess = (0, _child_process.spawn)(command, args, {
      cwd: process.cwd(),
      // Something to do with this, progress bar only shows if stdio is inherit
      // https://github.com/yarnpkg/yarn/issues/2200
      stdio: "inherit"
    });
    installProcess.on("error", function (err) {
      return reject(err);
    });
    installProcess.on("close", function (code) {
      if (code !== 0) {
        return reject(new Error("The install process exited with error code " + code + "."));
      }
      return resolve();
    });
  });
}

/**
 * Installs the peer dependencies of the provided packages
 * @param {Object} options - options for the install child_process
 * @param {string} options.packageName - the name of the package for which to install peer dependencies
 * @param {string} options.version - the version of the package
 * @param {string} options.packageManager - the package manager to use (Yarn or npm)
 * @param {string} options.registry - the URI of the registry to install from
 * @param {string} options.dev - whether to install the dependencies as devDependencies
 * @param {boolean} options.onlyPeers - whether to install the package itself or only its peers
 * @param {boolean} options.silent - whether to save the new dependencies to package.json (NPM only)
 * @param {boolean} options.dryRun - whether to actually install the packages or just display
 *                                   the resulting command
 * @param {Function} cb - the callback to call when the install process is finished
 */
function installPeerDeps(_ref2, cb) {
  var packageName = _ref2.packageName,
      version = _ref2.version,
      packageManager = _ref2.packageManager,
      registry = _ref2.registry,
      dev = _ref2.dev,
      global = _ref2.global,
      onlyPeers = _ref2.onlyPeers,
      silent = _ref2.silent,
      dryRun = _ref2.dryRun,
      auth = _ref2.auth,
      extraArgs = _ref2.extraArgs,
      proxy = _ref2.proxy;

  var encodedPackageName = encodePackageName(packageName);
  getPackageData({ encodedPackageName: encodedPackageName, registry: registry, auth: auth, proxy: proxy })
  // Catch before .then because the .then is so long
  .catch(function (err) {
    return cb(err);
  }).then(function (data) {
    var versions = Object.keys(data.versions);
    // Get max satisfying semver version
    var versionToInstall = (0, _semver.maxSatisfying)(versions, version);
    // If we didn't find a version, maybe it's a tag
    if (versionToInstall === null) {
      var tags = Object.keys(data["dist-tags"]);
      //  If it's not a valid tag, throw an error
      if (tags.indexOf(version) === -1) {
        return cb(new Error("That version or tag does not exist."));
      }
      // If the tag is valid, then find the version corresponding to the tag
      versionToInstall = data["dist-tags"][version];
    }

    // Get peer dependencies for max satisfying version
    var peerDepsVersionMap = data.versions[versionToInstall].peerDependencies;

    if (typeof peerDepsVersionMap === "undefined") {
      cb(new Error("The package you are trying to install has no peer " + "dependencies. Use yarn or npm to install it manually."));
    }

    // Construct packages string with correct versions for install
    // If onlyPeers option is true, don't install the package itself,
    // only its peers.
    var packagesString = onlyPeers ? "" : packageName + "@" + versionToInstall;
    Object.keys(peerDepsVersionMap).forEach(function (depName) {
      // Get the peer dependency version
      var peerDepVersion = peerDepsVersionMap[depName];
      // Check if there is whitespace
      if (peerDepVersion.indexOf(" ") >= 0) {
        // Semver ranges can have a join of comparator sets
        // e.g. '^3.0.2 || ^4.0.0' or '>=1.2.7 <1.3.0'
        // Take each version in the range and find the maxSatisfying
        var rangeSplit = peerDepVersion.split(" ").map(function (v) {
          return (0, _semver.coerce)(v);
        }).filter(function (v) {
          return (0, _semver.valid)(v);
        });
        var _versionToInstall = (0, _semver.maxSatisfying)(rangeSplit, peerDepVersion);
        if (_versionToInstall === null) {
          packagesString += " " + depName;
        } else {
          packagesString += " " + depName + "@" + _versionToInstall;
        }
      } else {
        packagesString += " " + depName + "@" + peerDepVersion;
      }
    });
    // Construct command based on package manager of current project
    var globalFlag = packageManager === C.yarn ? "global" : "--global";
    if (!global) {
      globalFlag = "";
    }
    var subcommand = packageManager === C.yarn ? "add" : "install";
    var devFlag = packageManager === C.yarn ? "--dev" : "--save-dev";
    if (!dev) {
      devFlag = "";
    }
    var isWindows = process.platform === "win32";
    var extra = "";
    if (isWindows) {
      // Spawn doesn't work without this extra stuff in Windows
      // See https://github.com/nodejs/node/issues/3675
      extra = ".cmd";
    }

    var args = [];
    // If any proxy setting were passed then include the http proxy agent.
    var requestProxy = process.env.HTTP_PROXY || process.env.http_proxy || "" + proxy;
    if (requestProxy !== "undefined") {
      args = args.concat("--proxy " + requestProxy);
    }
    // I know I can push it, but I'll just
    // keep concatenating for consistency
    // global must preceed add in yarn; npm doesn't care
    args = args.concat(globalFlag);
    args = args.concat(subcommand);
    // See issue #33 - issue with "-0"
    function fixPackageName(packageName) {
      if (packageName.substr(-2) === "-0") {
        // Remove -0
        return packageName.substr(0, packageName.length - 2);
      }
      return packageName;
    }
    // If we have spaces in our args spawn()
    // cries foul so we'll split the packagesString
    // into an array of individual packages
    args = args.concat(packagesString.split(" ").map(fixPackageName));
    // If devFlag is empty, then we'd be adding an empty arg
    // That causes the command to fail
    if (devFlag !== "") {
      args = args.concat(devFlag);
    }
    // If we're using NPM, and there's no dev flag,
    // and it's not a silent install and it's not a global install
    // make sure to save deps in package.json under "dependencies"
    if (devFlag === "" && packageManager === C.npm && !silent && !global) {
      args = args.concat("--save");
    }
    // If we are using NPM, and there's no dev flag,
    // and it IS a silent install,
    // explicitly pass the --no-save flag
    // (NPM v5+ defaults to using --save)
    if (devFlag === "" && packageManager === C.npm && silent) {
      args = args.concat("--no-save");
    }

    // Pass extra args through (after --)
    args = args.concat(extraArgs);

    // Remove empty args
    // There's a bug with Yarn 1.0 in which an empty arg
    // causes the install process to fail with a "malformed
    // response from the registry" error
    args = args.filter(function (a) {
      return a !== "";
    });

    //  Show user the command that's running
    var commandString = packageManager + " " + args.join(" ") + "\n";
    if (dryRun) {
      console.log("This command would have been run to install " + packageName + "@" + version + ":");
      console.log(commandString);
    } else {
      console.log("Installing peerdeps for " + packageName + "@" + version + ".");
      console.log(commandString);
      spawnInstall(packageManager + extra, args).then(function () {
        return cb(null);
      }).catch(function (err) {
        return cb(err);
      });
    }
  });
}

// Export for testing
exports.encodePackageName = encodePackageName;
exports.getPackageData = getPackageData;
exports.default = installPeerDeps;